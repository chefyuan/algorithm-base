哈喽大?好，我?厨子，之前我?说了二叉树前序遍历的?代法? Morris，今天咱?写一下中序遍历的?代法? Morris?

> ?：数?结构掌握不熟练的同?，阅??文章之前，?以先阅?这两篇文章，二叉树基?，前序遍历另外喜欢电脑阅读的同?，?以在小屋后台回?仓库地址，获? Github 链接进?阅读?

?序遍历的顺序?, `对于树中的某节点,先遍历?节点的左子?, 然后再遍历?节?, 最后遍历其右子树`。老?矩，上动画，我?先通过动画回忆一下二叉树的中序遍历?

![?序遍历](https://cdn.jsdelivr.net/gh/tan45du/test@master/photo/?序遍?.7gct7ztck8k0.gif)

?：二叉树基?总结大?可以阅读这篇文章，点我?

## ?代法

我们二叉树的?序遍历迭代法和前序遍历是一样的，都?借助栈来?助我?完成?

我们结合动画思考一下，该?何借助栈来实现??

我们来看下面这个动画?

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210608010104232.gif)

用栈实现的二叉树的中序遍历有两个关键的地方?

- 指针不断向节点的左?子移动，为了找到我?当前需要遍历的节点。途中不断执?入栈操?
- 当指针为空时，则开始出栈，并将指针指向出栈节点的右孩子?

这两?关键点也很?易理解，指针不?向左孩子移动，是为了找到我们此时需要节点。然后当指针指向空时，则说明我们此时已经找到该节点，执?出栈操作，并将其值存? list 即可，另外我?需要将指针指向出栈节点的右孩子，迭代执行上诉操作?

大?是不是已经知道怎么写啦，下面我?看代码吧?

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> arr = new ArrayList<>();
        TreeNode cur = new TreeNode(-1);
        cur = root;
        Stack<TreeNode> stack = new Stack<>();
        while (!stack.isEmpty() || cur != null) {
               //找到当前应?遍历的那个节点
               while (cur != null) {
                 stack.push(cur);
                 cur = cur.left;
               }
               //此时指针指向空，也就?没有左子节点，则开始执行出栈操?
               TreeNode temp = stack.pop();
               arr.add(temp.val);
               //指向右子节点
               cur = temp.right;
        }
        return arr;
    }
}
```

Swift Code?

```swift
class Solution {
    func inorderTraversal(_ root: TreeNode?) -> [Int] {
        var arr:[Int] = []
        var cur = root
        var stack:[TreeNode] = []

        while !stack.isEmpty || cur != nil {
            //找到当前应?遍历的那个节点
            while cur != nil {
                stack.append(cur!)
                cur = cur!.left
            }
            //此时指针指向空，也就?没有左子节点，则开始执行出栈操?
            if let temp = stack.popLast() {
                arr.append(temp.val)
                //指向右子节点
                cur = temp.right
            }
        }
        return arr
    }
}
```

Go Code:

```go
func inorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root == nil {
        return res
    }
    stk := []*TreeNode{}
    cur := root
    for len(stk) != 0 || cur != nil {
        // 找到当前应?遍历的那个节点，并且把左子节点都入?
        for cur != nil {
            stk = append(stk, cur)
            cur = cur.Left
        }
        // 没有左子节点，则开始执行出栈操?
        temp := stk[len(stk) - 1]
        stk = stk[: len(stk) - 1]
        res = append(res, temp.Val)
        cur = temp.Right
    }
    return res
}
```

### 

