> 如果阅?时，发现错?，或者动画不?以显示的?题可以添加我?信好? **[tan45du_one](https://raw.githubusercontent.com/tan45du/tan45du.github.io/master/?人微?.15egrcgqd94w.jpg)** ，?注 github + 题目 + ?? 向我反??
>
> 感谢?持，该仓库会一直维护，希望对各位有一?丢帮助?
>
> 另?希望手机阅读的同?可以来我的 <u>[**?众号：?厨的算法小?**](https://raw.githubusercontent.com/tan45du/test/master/?信图片_20210320152235.2pthdebvh1c0.png)</u> 两个平台同?，想?和题友一起刷题，互相监督的同学，?以在我的小屋点击<u>[**刷?小?**](https://raw.githubusercontent.com/tan45du/test/master/?信图片_20210320152235.2pthdebvh1c0.png)</u>进入?

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

这个题目，算?很经典的类型，我?的滑动窗口主要分为两种，一种的?变长度的滑动窗口，一种是固定长度的滑动窗口，这个题目算是固定长度的代表。今天我?用双?队列来解决我?这个题目，?会了这?题目的解题思想你可以去解决一下两道?目 [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)，[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)，虽然这两个题目和??类型不同，但是解?思路?一致的，都?很不错的题目，我认为做?，那些考察的很细的，解题思路很难想，即使想到，也不?易完全写出来的题目，才?能?大大提高我?编码能力的?目，希望能和大家一起进步?

这个题目我们用到?**双??队列**，队列里?保存的则为每段滑动窗口的最大值，我给大?做了一?动图，先来看一下代码执行过程吧?

我们先来了解下双?队列吧，队列我们都知道，?先进先出，双?队列?？既?以从队头出队，也?以从队尾出队，则不用遵循先进先出的?则?

下面我们通过一?动图来了解一下吧?

![](https://img-blog.csdnimg.cn/20210319154950406.gif)

好啦，我?了解双??队列?什么东东了，下面我?通过一?动画，来看一下代码的执?过程吧，相信各位一下就能?理解啦?

我们就通过题目?的例子来表述。nums = [1,3,-1,-3,5,3,6,7], k = 3

![](https://img-blog.csdnimg.cn/20210319162114967.gif)

不知道通过上面的例子能不能给各位描述清楚，如果不能的话，我再加把劲，各位看官，请接着往下看?

我们将执行过程进行拆解?

1.想将我们?一?窗口的所有值存入单调双?队列?，单调队列里面的值为单调递减的。?果发现队尾元素小于要加入的元素，则将队尾元素出队，直到队尾元素大于新元素时，再让新元素入队，目的就?维护一?单调递减的队列?

2.我们将??一?窗口的所有值，按照单调队列的?则入队之后，因为队列为单调递减，所以队头元素必为当前窗口的最大值，则将队头元素添加到数组中?

3.移动窗口，判?当前**窗口前的元素**?否和队头元素相等，?果相等则出队?

4.继续然后按照规则进?入队，维护单调递减队列?

5.每?将队头元素存到返回数组里?

5.返回数组

?不是懂啦，再回去看一遍??吧。?大家新年快乐，天天开心呀?

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if (len == 0) {
            return nums;
        }
        int[] arr = new int[len - k + 1];
        int arr_index = 0;
        //我们需要维护一?单调递减的双向队?
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < k; i++) {
             while (!deque.isEmpty() && deque.peekLast() < nums[i]) {
               deque.removeLast();
            }
            deque.offerLast(nums[i]);
        }
        arr[arr_index++] = deque.peekFirst();
        for (int j = k; j < len; j++) {
            if (nums[j - k] == deque.peekFirst()) {
                deque.removeFirst();
            }
            while (!deque.isEmpty() && deque.peekLast() < nums[j]) {
                deque.removeLast();
            }
            deque.offerLast(nums[j]);
            arr[arr_index++] = deque.peekFirst();
        }
        return arr;
    }
}
```

**GO?言版本?**

```go
func maxSlidingWindow(nums []int, k int) []int {
    l := len(nums)
    if l == 0 {
        return nums
    }

    arr   := []int{}
    // 维护一?单调递减的双向队?
    deque := []int{}
    for i := 0; i < k; i++ {
        for len(deque) != 0 && deque[len(deque) - 1] < nums[i] {
            deque = deque[:len(deque) - 1]
        }
        deque = append(deque, nums[i])
    }

    arr = append(arr, deque[0])
    for i := k; i < l; i++ {
        if nums[i - k] == deque[0] {
            deque = deque[1:]
        }
        for len(deque) != 0 && deque[len(deque) - 1] < nums[i] {
            deque = deque[:len(deque) - 1]
        }
        deque = append(deque, nums[i])
        arr = append(arr, deque[0])
    }
    return arr
}
```

